package resource

import (
	"encoding/json"
	"time"
	"unsafe"

	"github.com/grafana/grafana-plugin-sdk-go/data/converters"
	"github.com/grafana/grafana-plugin-sdk-go/data/utils/jsoniter"
	j "github.com/json-iterator/go"
)

func init() { //nolint:gochecknoinits
	jsoniter.RegisterTypeEncoder("resource.GenericDataQuery", &genericQueryCodec{})
	jsoniter.RegisterTypeDecoder("resource.GenericDataQuery", &genericQueryCodec{})
}

type QueryRequest[Q any] struct {
	// From Start time in epoch timestamps in milliseconds or relative using Grafana time units.
	// example: now-1h
	From string `json:"from,omitempty"`

	// To End time in epoch timestamps in milliseconds or relative using Grafana time units.
	// example: now
	To string `json:"to,omitempty"`

	// Each item has a
	Queries []Q `json:"queries"`

	// required: false
	Debug bool `json:"debug,omitempty"`
}

// GenericDataQuery is a replacement for `dtos.MetricRequest` with more explicit typing
type GenericDataQuery struct {
	CommonQueryProperties `json:",inline"`

	// Additional Properties (that live at the root)
	additional map[string]any `json:"-"` // note this uses custom JSON marshalling
}

// GenericQueryRequest is a query request that supports any datasource
type GenericQueryRequest = QueryRequest[GenericDataQuery]

// Generic query parser pattern.
type TypedQueryParser[Q any] interface {
	// Get the query parser for a query type
	// The version is split from the end of the discriminator field
	ParseQuery(
		// Properties that have been parsed off the same node
		common CommonQueryProperties,
		// An iterator with context for the full node (include common values)
		iter *jsoniter.Iterator,
		// Use this value as "now"
		now time.Time,
	) (Q, error)
}

var commonKeys = map[string]bool{
	"refId":            true,
	"resultAssertions": true,
	"timeRange":        true,
	"datasource":       true,
	"datasourceId":     true,
	"queryType":        true,
	"maxDataPoints":    true,
	"intervalMs":       true,
	"hide":             true,
}

var _ TypedQueryParser[GenericDataQuery] = (*GenericQueryParser)(nil)

type GenericQueryParser struct{}

// ParseQuery implements TypedQueryParser.
func (*GenericQueryParser) ParseQuery(common CommonQueryProperties, iter *jsoniter.Iterator, now time.Time) (GenericDataQuery, error) {
	q := GenericDataQuery{CommonQueryProperties: common, additional: make(map[string]any)}
	field, err := iter.ReadObject()
	for field != "" && err == nil {
		if !commonKeys[field] {
			q.additional[field], err = iter.Read()
			if err != nil {
				return q, err
			}
		}
		field, err = iter.ReadObject()
	}
	return q, err
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericDataQuery.
func (g *GenericDataQuery) DeepCopy() *GenericDataQuery {
	if g == nil {
		return nil
	}
	out := new(GenericDataQuery)
	jj, err := json.Marshal(g)
	if err != nil {
		_ = json.Unmarshal(jj, out)
	}
	return out
}

func (g *GenericDataQuery) DeepCopyInto(out *GenericDataQuery) {
	clone := g.DeepCopy()
	*out = *clone
}

// Set allows setting values using key/value pairs
func (g *GenericDataQuery) Set(key string, val any) *GenericDataQuery {
	switch key {
	case "refId":
		g.RefID, _ = val.(string)
	case "resultAssertions":
		body, err := json.Marshal(val)
		if err != nil {
			_ = json.Unmarshal(body, &g.ResultAssertions)
		}
	case "timeRange":
		body, err := json.Marshal(val)
		if err != nil {
			_ = json.Unmarshal(body, &g.TimeRange)
		}
	case "datasource":
		body, err := json.Marshal(val)
		if err != nil {
			_ = json.Unmarshal(body, &g.Datasource)
		}
	case "datasourceId":
		v, err := converters.JSONValueToInt64.Converter(val)
		if err != nil {
			g.DatasourceID, _ = v.(int64)
		}
	case "queryType":
		g.QueryType, _ = val.(string)
	case "maxDataPoints":
		v, err := converters.JSONValueToInt64.Converter(val)
		if err != nil {
			g.MaxDataPoints, _ = v.(int64)
		}
	case "intervalMs":
		v, err := converters.JSONValueToFloat64.Converter(val)
		if err != nil {
			g.IntervalMS, _ = v.(float64)
		}
	case "hide":
		g.Hide, _ = val.(bool)
	default:
		if g.additional == nil {
			g.additional = make(map[string]any)
		}
		g.additional[key] = val
	}
	return g
}

func (g *GenericDataQuery) Get(key string) (any, bool) {
	switch key {
	case "refId":
		return g.RefID, true
	case "resultAssertions":
		return g.ResultAssertions, true
	case "timeRange":
		return g.TimeRange, true
	case "datasource":
		return g.Datasource, true
	case "datasourceId":
		return g.DatasourceID, true
	case "queryType":
		return g.QueryType, true
	case "maxDataPoints":
		return g.MaxDataPoints, true
	case "intervalMs":
		return g.IntervalMS, true
	case "hide":
		return g.Hide, true
	}
	v, ok := g.additional[key]
	return v, ok
}

type genericQueryCodec struct{}

func (codec *genericQueryCodec) IsEmpty(_ unsafe.Pointer) bool {
	return false
}

func (codec *genericQueryCodec) Encode(ptr unsafe.Pointer, stream *j.Stream) {
	q := (*GenericDataQuery)(ptr)
	writeQuery(q, stream)
}

func (codec *genericQueryCodec) Decode(ptr unsafe.Pointer, iter *j.Iterator) {
	q := GenericDataQuery{}
	err := readQuery(&q, jsoniter.NewIterator(iter))
	if err != nil {
		// keep existing iter error if it exists
		if iter.Error == nil {
			iter.Error = err
		}
		return
	}
	*((*GenericDataQuery)(ptr)) = q
}

// MarshalJSON writes JSON including the common and custom values
func (g GenericDataQuery) MarshalJSON() ([]byte, error) {
	cfg := j.ConfigCompatibleWithStandardLibrary
	stream := cfg.BorrowStream(nil)
	defer cfg.ReturnStream(stream)

	writeQuery(&g, stream)
	return append([]byte(nil), stream.Buffer()...), stream.Error
}

// UnmarshalJSON reads a query from json byte array
func (g *GenericDataQuery) UnmarshalJSON(b []byte) error {
	iter, err := jsoniter.ParseBytes(jsoniter.ConfigDefault, b)
	if err != nil {
		return err
	}
	return readQuery(g, iter)
}

func writeQuery(g *GenericDataQuery, stream *j.Stream) {
	q := g.CommonQueryProperties
	stream.WriteObjectStart()
	stream.WriteObjectField("refId")
	stream.WriteVal(g.RefID)

	if q.ResultAssertions != nil {
		stream.WriteMore()
		stream.WriteObjectField("resultAssertions")
		stream.WriteVal(g.ResultAssertions)
	}

	if q.TimeRange != nil {
		stream.WriteMore()
		stream.WriteObjectField("timeRange")
		stream.WriteVal(g.TimeRange)
	}

	if q.Datasource != nil {
		stream.WriteMore()
		stream.WriteObjectField("datasource")
		stream.WriteVal(g.Datasource)
	}

	if q.DatasourceID > 0 {
		stream.WriteMore()
		stream.WriteObjectField("datasourceId")
		stream.WriteVal(g.DatasourceID)
	}

	if q.QueryType != "" {
		stream.WriteMore()
		stream.WriteObjectField("queryType")
		stream.WriteVal(g.QueryType)
	}

	if q.MaxDataPoints > 0 {
		stream.WriteMore()
		stream.WriteObjectField("maxDataPoints")
		stream.WriteVal(g.MaxDataPoints)
	}

	if q.IntervalMS > 0 {
		stream.WriteMore()
		stream.WriteObjectField("intervalMs")
		stream.WriteVal(g.IntervalMS)
	}

	if q.Hide {
		stream.WriteMore()
		stream.WriteObjectField("hide")
		stream.WriteVal(g.Hide)
	}

	// The additional properties
	if g.additional != nil {
		for k, v := range g.additional {
			stream.WriteMore()
			stream.WriteObjectField(k)
			stream.WriteVal(v)
		}
	}
	stream.WriteObjectEnd()
}

func readQuery(g *GenericDataQuery, iter *jsoniter.Iterator) error {
	var err error
	field := ""
	for field, err = iter.ReadObject(); field != ""; field, err = iter.ReadObject() {
		switch field {
		case "refId":
			g.RefID, err = iter.ReadString()
		case "resultAssertions":
			err = iter.ReadVal(&g.ResultAssertions)
		case "timeRange":
			err = iter.ReadVal(&g.TimeRange)
		case "datasource":
			err = iter.ReadVal(&g.Datasource)
		case "datasourceId":
			g.DatasourceID, err = iter.ReadInt64()
		case "queryType":
			g.QueryType, err = iter.ReadString()
		case "maxDataPoints":
			g.MaxDataPoints, err = iter.ReadInt64()
		case "intervalMs":
			g.IntervalMS, err = iter.ReadFloat64()
		case "hide":
			g.Hide, err = iter.ReadBool()
		default:
			v, err := iter.Read()
			if err != nil {
				return err
			}
			if g.additional == nil {
				g.additional = make(map[string]any)
			}
			g.additional[field] = v
		}
		if err != nil {
			return err
		}
	}
	return err
}
